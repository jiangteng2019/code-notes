# Linux的五种网络IO模型.md

Linux下的网络IO模型主要包括以下几种：

## 阻塞IO模型 (Blocking I/O)

这是最传统的IO模型，当一个进程发起一个IO请求（如读或写操作），进程将被阻塞直到IO操作完成。这意味着在等待IO期间，进程无法执行其他任务。
## 非阻塞IO模型 (Non-blocking I/O)

在非阻塞IO模型中，当一个进程发起IO请求时，如果数据不可用，系统不会阻塞进程，而是立即返回一个错误（通常是EAGAIN或EWOULDBLOCK）。这样，进程可以继续执行其他任务，但需要定期检查数据是否可用。
## I/O多路复用 (I/O Multiplexing)

这种模型允许一个进程同时监听多个文件描述符（如网络套接字）的状态变化。主要有三种技术实现：
select()：通过轮询一组文件描述符来检测是否有事件发生。它有一个限制，即能监控的文件描述符数量是有限的（通常受系统参数限制）。
poll()：与select()类似，但是没有文件描述符数量的限制，但是每次调用都需要复制文件描述符列表到内核空间，效率较低。
epoll()：是Linux 2.6内核引入的一种高效I/O多路复用技术。它使用事件驱动的方式，只通知有事件发生的文件描述符，从而避免了不必要的系统调用和上下文切换。
## 信号驱动IO模型 (Signal-driven I/O)

在这种模型中，当IO操作准备就绪时，操作系统会向进程发送一个信号。进程可以注册一个信号处理函数来响应这个信号，这样就可以在IO就绪时进行处理，而无需主动轮询。
## 异步IO模型 (Asynchronous I/O)

异步IO是最理想的IO模型，它允许进程发起一个IO请求，然后立即返回去做其他事情，而无需关心IO操作何时完成。当IO操作完成时，进程会收到一个通知。在Linux中，异步IO通过aio_read()和aio_write()函数实现。


每种模型都有其适用场景和局限性，选择哪种模型取决于具体的性能需求、资源限制和编程复杂度。例如，对于高并发服务，epoll 和 异步IO 是更优的选择，因为它们可以更有效地处理大量并发连接。而对于简单的服务，select 或者 poll 可能已经足够。

## 信号驱动IO模型与异步IO模型区别

这种模型与信号驱动模型的主要区别是：信号驱动I/O由内核通知我们何时可以开始一个I/O操作；异步I/O模型由内核通知我们I/O操作何时已经完成。

## 类比

我们可以将Linux的IO模型类比到餐厅点餐的情境中，以便更好地理解它们之间的差异。假设在一家餐厅中，顾客（线程）前来点餐（发起IO操作），而服务员（操作系统）负责处理点餐请求（IO操作）。

## 阻塞IO模型 (Blocking I/O)

当顾客点餐时，他必须坐在桌前等待，直到服务员把食物端上来。在这段时间里，顾客不能做任何其他事情。同样地，在阻塞IO模型中，进程在等待IO操作完成时会被阻塞，不能执行其他任务。
## 非阻塞IO模型 (Non-blocking I/O)

在非阻塞IO模型中，顾客询问服务员食物是否准备好，如果还没好，顾客不会被阻止离开餐桌去干别的事情，而是过一会儿再回来查看。这样，顾客可以在等待的过程中做其他事情，但需要自己不断检查食物是否准备好。
## I/O多路复用 (I/O Multiplexing)

这种模型就像顾客在餐厅里有一张大桌子，上面放着几个菜单，每个菜单代表一个不同的餐馆。顾客可以同时关注多个餐馆的食物准备情况，一旦某个餐馆的食物准备好了，服务员就会告诉顾客。顾客可以立即享用那家餐馆的食物，同时继续等待其他餐馆的食物。在I/O多路复用中，一个进程可以同时监听多个文件描述符，当任何一个描述符有事件发生时，进程都会得到通知。
## 信号驱动IO模型 (Signal-driven I/O)

类似于顾客在点餐后，给服务员留下电话号码，一旦食物准备好了，服务员会打电话通知顾客。顾客不需要一直询问食物的状态，也不需要一直守在餐桌旁。在信号驱动IO模型中，当IO操作准备就绪时，操作系统会发送一个信号给进程，进程可以注册一个信号处理函数来响应这个信号。

## 异步IO模型 (Asynchronous I/O)

在异步IO模型中，顾客点餐后可以自由离开餐厅去做其他事情，服务员会在食物准备完成后主动将食物送到顾客指定的地点。顾客不需要等待，也不需要主动查询食物的状态，这提供了最大的灵活性和效率。
通过这些类比，我们可以看出不同IO模型在处理并发请求和资源利用方面的差异。在实际应用中，选择合适的IO模型可以显著影响程序的性能和响应速度。